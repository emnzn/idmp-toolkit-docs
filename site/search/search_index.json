{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to IDMPToolkit","text":"<ul> <li> <p> Getting Started</p> <p>Install the package and begin your workflow in minutes.</p> <p> Start here</p> </li> <li> <p> Tutorials</p> <p>Step-by-step guides for patching, model usage, more.</p> <p> View tutorials</p> </li> <li> <p> Modules</p> <p>API reference for preprocess, segmentation, annotations, embeddings, and more.</p> <p> Explore modules</p> </li> <li> <p> Contributing</p> <p>Learn how to add functions, write docstrings, and submit PRs.</p> <p> Contribution guide</p> </li> <li> <p> Changelog</p> <p>Track what\u2019s new in each release of the toolkit.</p> <p> View changelog</p> </li> <li> <p> References</p> <p>Related research papers and background material.</p> <p> References</p> </li> </ul>"},{"location":"contributing/","title":"Contribute to IDMPToolkit","text":"<p>Please follow our branching and naming conventions to keep the repository clean and maintainable.</p>"},{"location":"contributing/#poetry-installation","title":"Poetry Installation","text":"<p>We use Poetry to manage dependencies and environments.  </p> <p>Installing Poetry is highly recommended for a seamless management of dependencies for our library. Please refer to the link above for installation instructions.</p>"},{"location":"contributing/#dependency-management","title":"Dependency Management","text":"<p>When developing functions that rely on dependencies that are not yet in <code>idmp-toolkit</code>, instead of performing an installation via <code>pip install &lt;package-name&gt;</code> or <code>conda install &lt;package-name&gt;</code>, please perform the installation as follows:</p> <pre><code>poetry add &lt;package-name&gt;\n</code></pre> <p>Note</p> <p>This command must be executed from the project root (the folder containing <code>pyproject.toml</code>). It will install the dependency into your environment and automatically list it as a dependency for <code>idmp-toolkit</code>, preventing dependency errors in future installations.</p>"},{"location":"contributing/#branching-convention","title":"Branching Convention","text":"<p>All work should be done in a feature branch, not directly on <code>main</code>. This ensures that <code>main</code> always remains stable and ready for release.</p>"},{"location":"contributing/#branch-naming-convention","title":"Branch naming convention","text":"<p><pre><code># Branch naming convention:\nfeature/&lt;module&gt;-&lt;task&gt;-&lt;function&gt;-&lt;contributor_name&gt;\n</code></pre> Examples:</p> <ul> <li><code>feature/preprocess-mask-eric</code></li> <li><code>feature/preprocess-patch-yijing</code></li> <li><code>feature/models-segmentation-chengxiang</code></li> <li><code>feature/data-split-haoda</code></li> </ul> <p>This format makes it easy to see what is being developed in each branch at a glance.</p>"},{"location":"contributing/#creating-a-branch","title":"Creating a Branch","text":"<p>Always start from the latest <code>main</code> branch:</p> <pre><code># Update local main\ngit checkout main\ngit pull origin main\n\n# Create a feature branch\ngit checkout -b feature/&lt;task&gt;-&lt;function&gt;-&lt;contributor-name&gt;\ngit push -u origin feature/&lt;task&gt;-&lt;function&gt;-&lt;contributor-name&gt;\n</code></pre>"},{"location":"contributing/#pushing-to-a-branch","title":"Pushing to a Branch","text":"<pre><code>git add .\ngit commit -m \"Add rule-based tissue masking\"\ngit push -u origin feature/preprocess-mask-&lt;contributor-name&gt;\n</code></pre>"},{"location":"contributing/#code-convention","title":"Code Convention","text":""},{"location":"contributing/#typing","title":"Typing","text":"<p>Always use Python type hints for function signatures and class methods.</p> <pre><code>def threshold_segmenter(\n    slide: np.ndarray,\n    apply_morphological_closing: bool = True,\n    ksize: int = 3\n    ) -&gt; np.ndarray:\n\n    ...\n</code></pre> <p>Specifying the expected input and return types makes functions easier to use and maintain, as future modifications only need to preserve these types to prevent errors.</p>"},{"location":"contributing/#docstrings","title":"Docstrings","text":"<p>Document every function, and class using NumPy-style docstrings. Clear docstrings describe what a function does, explain its parameters and return values, and make the codebase easier to use and extend.</p> <pre><code>def threshold_segmenter(\n    slide: np.ndarray,\n    apply_morphological_closing: bool = True,\n    ksize: int = 3\n    ) -&gt; np.ndarray:\n\n    \"\"\"\n    Segments tissue regions by thresholding the saturation channel \n    with otsu.\n\n    Parameters\n    ----------\n    slide: np.ndarray\n        The image as a numpy array.\n        The image is assumed to be in RGB.\n\n    apply_morphological_closing: bool\n        Whether to close small gaps in the tissue\n\n    ksize: \n        The kernel size for blurring and morphological closing.\n        Must be odd.\n\n    Returns\n    -------\n    tissue_mask: np.ndarray\n        The segmented tissue mask.\n    \"\"\"\n\n    ...\n\n    return tissue_mask\n</code></pre> <p>Please refer to this guide for more details.</p>"},{"location":"contributing/#avoiding-branch-conflicts","title":"Avoiding Branch Conflicts","text":"<p>Our library is developed by multiple contributors, often working on similar tasks in different ways.  </p> <p>For example:  </p> <ul> <li>Preprocess</li> <li><code>mask</code>: rule-based and model-based tissue masking (LJ, XM, EM, HD)  </li> <li><code>iam</code>: image augmentation methods (XM, HD)  </li> <li><code>patch</code>: sliding window and random patching (XM, HD, ER, ZR)  </li> <li> <p><code>wsi_constructor</code>: reconstruct WSIs from patches (XM, ER, HD, ZR)  </p> </li> <li> <p>Visualization</p> </li> <li> <p><code>annotation_stats</code>: number of slides per class, annotations, and area stats (KH, JA, SY)  </p> </li> <li> <p>Data</p> </li> <li><code>split</code>: data splitting functions (EM, HD)  </li> <li> <p><code>qc</code>: quality control checks (LJ)  </p> </li> <li> <p>Models</p> </li> <li><code>foundation</code>, <code>segmentation</code>, <code>classification</code> </li> </ul> <p>If everyone edited a single <code>preprocess.py</code> or <code>models.py</code> file, merge conflicts would happen frequently. The codebase would also become harder to maintain and refactor over time.</p>"},{"location":"contributing/#the-role-of-__init__py","title":"The Role of <code>__init__.py</code>","text":"<p>Instead of forcing everything into one large file, each group of functions lives in its own submodule (<code>mask.py</code>, <code>patch.py</code>, <code>split.py</code>, etc.).  </p> <p><code>__init__.py</code> then fuses these submodules into a clean public API.  </p>"},{"location":"contributing/#benefits","title":"Benefits","text":"<ul> <li>Conflict reduction \u2013 contributors work in separate files, avoiding merge conflicts.  </li> <li>Stable API surface \u2013 users import from <code>idmp.preprocess</code> or <code>idmp.data</code> without worrying about internal file layout.  </li> <li>Future flexibility \u2013 we can reorganize files as the library grows, while keeping the same import paths for users.  </li> <li>Cleaner organization \u2013 related functionality is grouped into smaller, focused files.  </li> </ul>"},{"location":"contributing/#example-folder-layout","title":"Example Folder Layout","text":"<pre><code>idmp/\n\u251c\u2500\u2500 preprocess/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 mask.py\n\u2502   \u251c\u2500\u2500 iam.py\n\u2502   \u251c\u2500\u2500 patch.py\n\u2502   \u2514\u2500\u2500 wsi_constructor.py\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 foundation.py\n\u2502   \u2514\u2500\u2500 segmentation.py\n</code></pre>"},{"location":"contributing/#example-__init__py","title":"Example <code>__init__.py</code>","text":"<pre><code># idmp/preprocess/__init__.py\n\nfrom .iam import match_histogram\nfrom .wsi_constructor import reconstruct_wsi\nfrom .patch import sliding_window, random_patch\nfrom .mask import threshold_segmenter, model_segmenter\n\n__all__ = [\n    \"threshold_segmenter\",\n    \"model_segmenter\",\n    \"match_histogram\",\n    \"sliding_window\",\n    \"random_patch\",\n    \"reconstruct_wsi\",\n]\n</code></pre>"},{"location":"contributing/#simplified-imports","title":"Simplified Imports","text":"<p>Without <code>__init__.py</code>:</p> <pre><code>from idmp.preprocess.mask import rule_based_mask\nfrom idmp.preprocess.patch import sliding_window\n</code></pre> <p>With <code>__init__.py</code>:</p> <pre><code>from idmp.preprocess import rule_based_mask, sliding_window\n</code></pre> <p>Users only interact with a flat, stable API, while contributors can keep adding new files without breaking imports.  </p> <p>This way, contributors can focus on their feature, while the library maintains a clean, conflict-resistant structure.</p>"},{"location":"getting_started/","title":"Getting started with IDMPToolkit","text":""},{"location":"getting_started/#1-setup-ssh-keys-with-gitea","title":"1. Setup SSH Keys with Gitea","text":"<p>To install the package, make sure your SSH keys are configured with the lab's Git server. For a step-by-step guide, refer to the GitHub documentation.</p> <p>Once setup, you can test your connection:</p> <pre><code>ssh -T git@git.cdplab.org\n</code></pre>"},{"location":"getting_started/#2-package-installation","title":"2. Package Installation","text":"<p>Create a virtual environment:</p> <pre><code>conda create -n idmp python=3.11\n</code></pre> <p>Enter virtual environment:</p> <pre><code>conda activate idmp\n</code></pre> <p>You can install the package directly from the lab\u2019s private Git server:</p> <pre><code>pip install git+ssh://git@git.cdplab.org/ericmonzon/idmp-toolkit.git\n</code></pre>"}]}